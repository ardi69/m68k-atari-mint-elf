Index: config-ml.in
===================================================================
--- config-ml.in	(Revision 2)
+++ config-ml.in	(Arbeitskopie)
@@ -346,6 +346,23 @@
 	    esac
 	  done
 	fi
+	case "${host}" in
+	  *-*-mint*)
+	    case "${srcdir}" in
+	      */libgcc ) : ;;
+	      *)
+	        old_multidirs="${multidirs}"
+	        multidirs=""
+	        for x in ${old_multidirs}; do
+		  case "$x" in
+		    *mshort ) : ;;
+		    *) multidirs="${multidirs} ${x}" ;;
+		  esac
+		done
+		;;
+	    esac
+	    ;;
+	esac
 	;;
 mips*-*-*)
 	if [ x$enable_single_float = xno ]
Index: config.guess
===================================================================
--- config.guess	(Revision 2)
+++ config.guess	(Arbeitskopie)
@@ -439,22 +439,22 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint
 	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint${UNAME_RELEASE}
+	echo m68k-milan-mint
 	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint${UNAME_RELEASE}
+	echo m68k-hades-mint
 	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint${UNAME_RELEASE}
+	echo m68k-unknown-mint
 	exit ;;
     m68k:machten:*:*)
 	echo m68k-apple-machten${UNAME_RELEASE}
Index: configure
===================================================================
--- configure	(Revision 2)
+++ configure	(Arbeitskopie)
@@ -3501,6 +3501,9 @@
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
     libgloss_dir=m68hc11
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
   m68*-*-* | fido-*-*)
     libgloss_dir=m68k
     ;;
Index: configure.ac
===================================================================
--- configure.ac	(Revision 2)
+++ configure.ac	(Arbeitskopie)
@@ -832,6 +832,9 @@
   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
     libgloss_dir=m68hc11
     ;;
+  m68k-*-mint*)
+    noconfigdirs="$noconfigdirs target-libiberty ${libgcj}"
+    ;;
   m68*-*-* | fido-*-*)
     libgloss_dir=m68k
     ;;
Index: gcc/c/c-decl.c
===================================================================
--- gcc/c/c-decl.c	(Revision 2)
+++ gcc/c/c-decl.c	(Arbeitskopie)
@@ -4809,6 +4809,19 @@
 	ce = declarator->declarator;
       if (ce->kind == cdk_function)
 	{
+		bool need_restore=false;
+		tree orig_integer_type_node = integer_type_node;
+		tree orig_unsigned_type_node = unsigned_type_node;
+		if (!TARGET_SHORT && lookup_attribute ("shortcall", attributes)) {
+			need_restore = true;
+			integer_type_node = short_integer_type_node; // fake int_types
+			unsigned_type_node = short_unsigned_type_node;
+		}
+		if (TARGET_SHORT && lookup_attribute ("longcall", attributes)) {
+			need_restore = true;
+			integer_type_node = long_integer_type_node; // fake int_types
+			unsigned_type_node = long_unsigned_type_node;
+		}
 	  tree args = ce->u.arg_info->parms;
 	  for (; args; args = DECL_CHAIN (args))
 	    {
@@ -4817,6 +4830,10 @@
 		  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))
 		DECL_ARG_TYPE (args) = c_type_promotes_to (type);
 	    }
+		if (need_restore) { // restore int_types
+			integer_type_node = orig_integer_type_node;
+			unsigned_type_node = orig_unsigned_type_node;
+		}
 	}
     }
 
@@ -9412,9 +9429,24 @@
     objc_finish_function ();
 
   if (TREE_CODE (fndecl) == FUNCTION_DECL
-      && targetm.calls.promote_prototypes (TREE_TYPE (fndecl)))
+      && targetm.calls.promote_prototypes (TREE_TYPE(fndecl)))
     {
       tree args = DECL_ARGUMENTS (fndecl);
+
+		bool need_restore=false;
+		tree orig_integer_type_node = integer_type_node;
+		tree orig_unsigned_type_node = unsigned_type_node;
+		if (!TARGET_SHORT && lookup_attribute ("shortcall", TYPE_ATTRIBUTES (TREE_TYPE(fndecl)))) {
+			need_restore = true;
+			integer_type_node = short_integer_type_node; // fake int_types
+			unsigned_type_node = short_unsigned_type_node;
+		}
+		if (!TARGET_SHORT && lookup_attribute ("longcall", TYPE_ATTRIBUTES (TREE_TYPE(fndecl)))) {
+			need_restore = true;
+			integer_type_node = long_integer_type_node; // fake int_types
+			unsigned_type_node = long_unsigned_type_node;
+		}
+
       for (; args; args = DECL_CHAIN (args))
 	{
 	  tree type = TREE_TYPE (args);
@@ -9422,6 +9454,10 @@
 	      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))
 	    DECL_ARG_TYPE (args) = c_type_promotes_to (type);
 	}
+		if (need_restore) { // restore int_types
+			integer_type_node = orig_integer_type_node;
+			unsigned_type_node = orig_unsigned_type_node;
+		}
     }
 
   if (DECL_INITIAL (fndecl) && DECL_INITIAL (fndecl) != error_mark_node)
Index: gcc/c/c-typeck.c
===================================================================
--- gcc/c/c-typeck.c	(Revision 2)
+++ gcc/c/c-typeck.c	(Arbeitskopie)
@@ -3071,11 +3071,33 @@
   /* fntype now gets the type of function pointed to.  */
   fntype = TREE_TYPE (fntype);
 
+	{
+		bool need_restore=false;
+		tree orig_integer_type_node = integer_type_node;
+		tree orig_unsigned_type_node = unsigned_type_node;
+		if (!TARGET_SHORT && lookup_attribute ("shortcall", TYPE_ATTRIBUTES(fntype))) {
+			need_restore=true;
+			integer_type_node = short_integer_type_node; // fake int_types
+			unsigned_type_node = short_unsigned_type_node;
+		}
+		if (TARGET_SHORT && lookup_attribute ("longcall", TYPE_ATTRIBUTES(fntype))) {
+			need_restore=true;
+			integer_type_node = long_integer_type_node; // fake int_types
+			unsigned_type_node = long_unsigned_type_node;
+		}
+
   /* Convert the parameters to the types declared in the
      function prototype, or apply default promotions.  */
 
   nargs = convert_arguments (loc, arg_loc, TYPE_ARG_TYPES (fntype), params,
 			     origtypes, function, fundecl);
+
+		if(need_restore) { // restore faket int_types
+			integer_type_node = orig_integer_type_node;
+			unsigned_type_node = orig_unsigned_type_node;
+		}
+	}
+
   if (nargs < 0)
     return error_mark_node;
 
Index: gcc/calls.c
===================================================================
--- gcc/calls.c	(Revision 2)
+++ gcc/calls.c	(Arbeitskopie)
@@ -3211,7 +3211,29 @@
    If IGNORE is nonzero, then we ignore the value of the function call.  */
 
 rtx
-expand_call (tree exp, rtx target, int ignore)
+orig_expand_call (tree exp, rtx target, int ignore);
+rtx
+expand_call (tree exp, rtx target, int ignore) {
+	tree funtype = get_callee_fndecl (exp);
+	if (!funtype) funtype = TREE_TYPE (CALL_EXPR_FN (exp));
+	funtype = TREE_TYPE(funtype);
+	bool need_restore=false;
+	if (TREE_CODE (funtype) == FUNCTION_TYPE || TREE_CODE (funtype) == METHOD_TYPE) {
+		if ((!TARGET_SHORT && lookup_attribute ("shortcall", TYPE_ATTRIBUTES (funtype)))
+			|| (TARGET_SHORT && lookup_attribute ("longcall", TYPE_ATTRIBUTES (funtype)))) {
+			need_restore = true;
+			target_flags ^= MASK_SHORT;
+		}
+	}
+
+	rtx ret = orig_expand_call (exp, target, ignore);
+
+	if (need_restore) target_flags ^= MASK_SHORT;
+	return ret;
+}
+
+rtx
+orig_expand_call (tree exp, rtx target, int ignore)
 {
   /* Nonzero if we are currently expanding a call.  */
   static int currently_expanding_call = 0;
Index: gcc/common.opt
===================================================================
--- gcc/common.opt	(Revision 2)
+++ gcc/common.opt	(Arbeitskopie)
@@ -2442,8 +2442,9 @@
 Common Report Var(time_report_details)
 Record times taken by sub-phases separately.
 
+; on atari-mint defaulted to TLS_MODEL_LOCAL_EXEC
 ftls-model=
-Common Joined RejectNegative Enum(tls_model) Var(flag_tls_default) Init(TLS_MODEL_GLOBAL_DYNAMIC)
+Common Joined RejectNegative Enum(tls_model) Var(flag_tls_default) Init(TLS_MODEL_LOCAL_EXEC)
 -ftls-model=[global-dynamic|local-dynamic|initial-exec|local-exec]	Set the default thread-local storage code generation model.
 
 Enum
Index: gcc/config.gcc
===================================================================
--- gcc/config.gcc	(Revision 2)
+++ gcc/config.gcc	(Arbeitskopie)
@@ -1999,6 +1999,17 @@
 	tm_defines="${tm_defines} MOTOROLA=1"
 	tmake_file="${tmake_file} m68k/t-floatlib m68k/t-linux m68k/t-mlibs"
 	;;
+m68k-*-mint*)
+	default_m68k_cpu=68000
+	default_cf_cpu=5475
+	tm_file="${tm_file} m68k/mint.h"
+	extra_options="${extra_options} m68k/mint.opt"
+	tm_defines="${tm_defines} MOTOROLA=1"
+	tmake_file="m68k/t-floatlib m68k/t-mint"
+	gas=yes
+	gnu_ld=yes
+	inhibit_libc=true
+	;;
 m68k-*-rtems*)
 	default_m68k_cpu=68020
 	default_cf_cpu=5206
Index: gcc/config/m68k/m68k-protos.h
===================================================================
--- gcc/config/m68k/m68k-protos.h	(Revision 2)
+++ gcc/config/m68k/m68k-protos.h	(Arbeitskopie)
@@ -100,3 +100,15 @@
 extern rtx m68k_legitimize_sibcall_address (rtx);
 extern int m68k_hard_regno_rename_ok(unsigned int, unsigned int);
 extern poly_int64 m68k_push_rounding (poly_int64);
+
+#ifdef RTX_CODE
+#ifdef TREE_CODE
+extern void m68k_init_cumulative_args (CUMULATIVE_ARGS *, tree);
+//extern void m68k_function_arg_advance (CUMULATIVE_ARGS *);
+//extern rtx m68k_function_arg (CUMULATIVE_ARGS *, enum machine_mode,
+//			      const_tree, bool);
+extern bool m68k_fastcall_function(const_tree fndecl_or_fntype);
+extern void m68k_profile_function(FILE *file, int funcdef_no, unsigned long saved_regs);
+#endif
+#endif
+void m68k_order_regs_for_local_alloc (void);
Index: gcc/config/m68k/m68k.c
===================================================================
--- gcc/config/m68k/m68k.c	(Revision 3)
+++ gcc/config/m68k/m68k.c	(Arbeitskopie)
@@ -65,6 +65,7 @@
 #include "optabs.h"
 #include "builtins.h"
 #include "rtl-iter.h"
+#include "langhooks.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
@@ -155,6 +156,7 @@
 static int m68k_sched_first_cycle_multipass_dfa_lookahead (void);
 
 static bool m68k_can_eliminate (const int, const int);
+static void m68k_set_current_function (tree);
 static void m68k_conditional_register_usage (void);
 static bool m68k_legitimate_address_p (machine_mode, rtx, bool);
 static void m68k_option_override (void);
@@ -163,10 +165,17 @@
 static const char *singlemove_string (rtx *);
 static void m68k_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,
 					  HOST_WIDE_INT, tree);
+static bool m68k_promote_prototypes (const_tree);
 static rtx m68k_struct_value_rtx (tree, int);
 static tree m68k_handle_fndecl_attribute (tree *node, tree name,
 					  tree args, int flags,
 					  bool *no_add_attrs);
+static tree m68k_handle_fntype_attribute (tree *node, tree name,
+					  tree args, int flags,
+					  bool *no_add_attrs);
+static int m68k_comp_type_attributes (const_tree, const_tree);
+static rtx m68k_static_chain (const_tree fndecl_or_type, bool incoming_p);
+
 static void m68k_compute_frame_layout (void);
 static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);
 static bool m68k_ok_for_sibcall_p (tree, tree);
@@ -187,6 +196,7 @@
 static bool m68k_cannot_force_const_mem (machine_mode mode, rtx x);
 static bool m68k_output_addr_const_extra (FILE *, rtx);
 static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
+static void m68k_finish_slb_export ();
 static enum flt_eval_method
 m68k_excess_precision (enum excess_precision_type);
 static unsigned int m68k_hard_regno_nregs (unsigned int, machine_mode);
@@ -230,6 +240,9 @@
 #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK
 #define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true
 
+#undef TARGET_ASM_FILE_END
+#define TARGET_ASM_FILE_END m68k_finish_slb_export
+
 #undef TARGET_ASM_FILE_START_APP_OFF
 #define TARGET_ASM_FILE_START_APP_OFF true
 
@@ -277,7 +290,7 @@
 #define TARGET_ATTRIBUTE_TABLE m68k_attribute_table
 
 #undef TARGET_PROMOTE_PROTOTYPES
-#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+#define TARGET_PROMOTE_PROTOTYPES m68k_promote_prototypes
 
 #undef TARGET_STRUCT_VALUE_RTX
 #define TARGET_STRUCT_VALUE_RTX m68k_struct_value_rtx
@@ -310,6 +323,9 @@
 #undef TARGET_CAN_ELIMINATE
 #define TARGET_CAN_ELIMINATE m68k_can_eliminate
 
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION m68k_set_current_function
+
 #undef TARGET_CONDITIONAL_REGISTER_USAGE
 #define TARGET_CONDITIONAL_REGISTER_USAGE m68k_conditional_register_usage
 
@@ -352,8 +368,39 @@
 #undef TARGET_PROMOTE_FUNCTION_MODE
 #define TARGET_PROMOTE_FUNCTION_MODE m68k_promote_function_mode
 
-static const struct attribute_spec m68k_attribute_table[] =
+#undef TARGET_STATIC_CHAIN
+#define TARGET_STATIC_CHAIN m68k_static_chain
+
+static const struct attribute_spec::exclusions m68k_attr_shortcall_exclusions[] =
 {
+  { "loncall", true, true, true },
+  { NULL, false, false, false },
+};
+static const struct attribute_spec::exclusions m68k_attr_longcall_exclusions[] =
+{
+  { "shortcall", true, true, true },
+  { NULL, false, false, false },
+};
+static const struct attribute_spec::exclusions m68k_attr_fastcall_exclusions[] =
+{
+  { "stkparm", true, true, true },
+  { "regparm", true, true, true },
+  { NULL, false, false, false },
+};
+static const struct attribute_spec::exclusions m68k_attr_stkparm_exclusions[] =
+{
+  { "fastcall", true, true, true },
+  { "regparm", true, true, true },
+  { NULL, false, false, false },
+};
+static const struct attribute_spec::exclusions m68k_attr_regparm_exclusions[] =
+{
+  { "fastcall", true, true, true },
+  { "stkparm", true, true, true },
+  { NULL, false, false, false },
+};
+static struct attribute_spec m68k_attribute_table[] =
+{
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req,
        affects_type_identity, handler, exclude } */
   { "interrupt", 0, 0, true,  false, false, false,
@@ -362,9 +409,44 @@
     m68k_handle_fndecl_attribute, NULL },
   { "interrupt_thread", 0, 0, true,  false, false, false,
     m68k_handle_fndecl_attribute, NULL },
+
+  { "slb_export", 1, 1, true, false, false, false,
+    m68k_handle_fndecl_attribute, NULL },
+
+  { "shortcall", 0, 0, false, true, true, true,
+    m68k_handle_fntype_attribute, NULL },
+  { "longcall", 0, 0, false, true, true, false,
+    m68k_handle_fntype_attribute, NULL },
+  { "fastcall", 0, 0, false, true, true, true,
+    m68k_handle_fntype_attribute, m68k_attr_fastcall_exclusions },
+  { "stkparm", 0, 0, false, true, true, false,
+    m68k_handle_fntype_attribute, m68k_attr_stkparm_exclusions },
+  { "regparm", 0, 1, false, true, true, true,
+    m68k_handle_fntype_attribute, m68k_attr_regparm_exclusions },
   { NULL, 0, 0, false, false, false, false, NULL, NULL }
 };
 
+static attribute_spec *m68_lookup_attribute_spec(const char *name) {
+	attribute_spec *ret = m68k_attribute_table;
+	for ( ; ret->name; ++ret) {
+		if (strcmp(ret->name, name) == 0) break;
+	}
+	return ret;
+}
+static void m68k_init_attribute_spec() {
+printf("init attribute spec\n");
+	if(TARGET_SHORT) {
+		m68_lookup_attribute_spec("shortcall")->affects_type_identity = false;
+		m68_lookup_attribute_spec("longcall")->affects_type_identity = true;
+	}
+	if(TARGET_FASTCALL) {
+		m68_lookup_attribute_spec("fastcall")->affects_type_identity = false;
+		m68_lookup_attribute_spec("stkparm")->affects_type_identity = true;
+	}
+}
+#undef TARGET_COMP_TYPE_ATTRIBUTES
+#define TARGET_COMP_TYPE_ATTRIBUTES m68k_comp_type_attributes
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 /* Base flags for 68k ISAs.  */
@@ -767,8 +849,18 @@
   return m68k_fk_normal_function;
 }
 
+static HOST_WIDE_INT
+m68k_get_slb_export_slot(tree fndecl) {
+  tree slb_export = lookup_attribute ("slb_export", DECL_ATTRIBUTES (fndecl));
+  if(slb_export) {
+    return int_cst_value (TREE_VALUE(TREE_VALUE(slb_export)));
+  }
+  return -1;
+}
+
 /* Handle an attribute requiring a FUNCTION_DECL; arguments as in
    struct attribute_spec.handler.  */
+
 static tree
 m68k_handle_fndecl_attribute (tree *node, tree name,
 			      tree args ATTRIBUTE_UNUSED,
@@ -782,6 +874,27 @@
       *no_add_attrs = true;
     }
 
+  if (!strcmp (IDENTIFIER_POINTER (name), "slb_export")) {
+    if(TREE_CODE (TREE_TYPE (*node)) == FUNCTION_TYPE && decl_function_context (*node) == 0) {
+      tree arg;
+      arg = TREE_VALUE (args);
+      if(TREE_CODE(arg) != INTEGER_CST) {
+        warning (OPT_Wattributes, "`%qE' invalid slb_export slot (must be an integer beetween 0 and 1023) --> attribute ignored", name);
+        *no_add_attrs = true;
+      } else {
+        HOST_WIDE_INT val = int_cst_value(arg);
+        if ( 0 > val || val > 1023) {
+          warning (OPT_Wattributes, "`%qE' invalid slb_export slot (get %i but must be beetween 0 and 1023) --> attribute ignored", name, (int)val);
+          *no_add_attrs = true;
+        }
+      }
+    } else {
+      warning (OPT_Wattributes, "`%qE' attribute ignored", name);
+      *no_add_attrs = true;
+    }
+    return NULL_TREE;
+  }
+
   if (m68k_get_function_kind (*node) != m68k_fk_normal_function)
     {
       error ("multiple interrupt attributes not allowed");
@@ -798,7 +911,141 @@
   return NULL_TREE;
 }
 
+
+static tree
+m68k_handle_fntype_attribute (tree *node, tree name,
+			      tree args ATTRIBUTE_UNUSED,
+			      int flags ATTRIBUTE_UNUSED,
+			      bool *no_add_attrs)
+{
+	static bool attribute_spec_inited = false;
+	if (!attribute_spec_inited) { attribute_spec_inited = true; m68k_init_attribute_spec(); }
+
+	if (TREE_CODE (*node) != FUNCTION_TYPE && TREE_CODE (*node) != METHOD_TYPE)
+	{
+		warning (OPT_Wattributes, "`%qE' only applies to functions", name);
+		*no_add_attrs = true;
+	} else if (is_attribute_p ("shortcall", name)) {
+		if(lang_GNU_CXX()) {
+			warning (OPT_Wattributes, "`%qE' is currently not available for c++ ", name);
+			*no_add_attrs = true;
+		}
+	}
+	return NULL_TREE;
+}
+
+/* Return true if the function use the fastcall abi */
+bool m68k_fastcall_function(const_tree fndecl_or_type) {
+	if (!fndecl_or_type) return TARGET_FASTCALL;
+//	printf("%S TREE_CODE (fndecl_or_type) %i == FUNCTION_DECL %i\n", __FUNCTION__, TREE_CODE (fndecl_or_type), FUNCTION_DECL);
+	if (TREE_CODE (fndecl_or_type) == FUNCTION_DECL) fndecl_or_type = TREE_TYPE (fndecl_or_type);
+//	printf("%S TREE_CODE (fndecl_or_type) %i == FUNCTION_TYPE %i\n", __FUNCTION__, TREE_CODE (fndecl_or_type), FUNCTION_TYPE);
+	return ((TARGET_FASTCALL && !lookup_attribute ("stkparm", TYPE_ATTRIBUTES (fndecl_or_type)) && !lookup_attribute ("regparm", TYPE_ATTRIBUTES (fndecl_or_type)))
+			|| (!TARGET_FASTCALL && lookup_attribute ("fastcall", TYPE_ATTRIBUTES (fndecl_or_type))));
+}
+
+
+/* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,
+   one if they are compatible, and two if they are nearly compatible
+   (which causes a warning to be generated). */
+static int
+m68k_comp_type_attributes (const_tree type1 ATTRIBUTE_UNUSED, const_tree type2 ATTRIBUTE_UNUSED)
+{
+	/* Functions or methods are incompatible if they specify mutually
+	exclusive ways of passing arguments.  */
+	if (TREE_CODE (type1) == FUNCTION_TYPE || TREE_CODE (type1) == METHOD_TYPE)
+	{
+		return 0;
+	}
+	return 1;
+}
+
+static
+rtx m68k_static_chain (const_tree fndecl_or_type, bool incoming_p) {
+	if(m68k_fastcall_function(fndecl_or_type))
+		return gen_rtx_REG (Pmode, M68K_FASTCALL_STATIC_CHAIN_REGNUM);
+	return default_static_chain (fndecl_or_type, incoming_p);
+}
+
+
+
+static char m68k_slb_export_tab[128];
+static int m68k_slb_export_tab_max=-1;
+
 static void
+m68k_finish_slb_export ()
+{
+//  fprintf (asm_out_file, "\t/* slb_export by ardi */\n");
+  char buf[32];
+  if(m68k_slb_export_tab_max == -1)
+    return;
+  for(int slot=0; slot<=m68k_slb_export_tab_max; ++slot) {
+    if(m68k_slb_export_tab[slot >> 3] & (1 << (slot & 0x07)))
+      continue;
+    sprintf (buf, "%s.%.4u", ".gnu.linkonce.slb_export", (unsigned)slot);
+    switch_to_section (get_section (buf, SECTION_WRITE, NULL));
+    assemble_align (POINTER_SIZE);
+    sprintf (buf, "%s_%.4u", ".slb_export", (unsigned)slot);
+    fprintf (asm_out_file, "\t.weak %s\n\t.long %s\n", buf, buf);
+  }
+  m68k_slb_export_tab_max = -1;
+}
+
+void
+m68k_compute_slb_export (tree fndecl)
+{
+  char section[32], label[32];
+
+  rtx symbol = XEXP (DECL_RTL (fndecl), 0);
+  const char *name = XSTR (symbol, 0);
+
+  HOST_WIDE_INT slot = m68k_get_slb_export_slot(fndecl);
+  if(slot<0) return;
+
+  if(m68k_slb_export_tab_max == -1) memset(m68k_slb_export_tab, 0, sizeof(m68k_slb_export_tab));
+  if(m68k_slb_export_tab_max < slot) m68k_slb_export_tab_max = slot;
+  m68k_slb_export_tab[slot >> 3] |= (1 << (slot & 0x07));
+
+  /* ??? This only works reliably with the GNU linker.  */
+  sprintf (section, "%s.%.4u", ".gnu.linkonce.slb_export", (unsigned)slot);
+  sprintf (label, "%s_%.4u", ".slb_export", (unsigned)slot);
+
+  fprintf (asm_out_file, "\t.globl %s\n\t.set %s, ", label, label);
+  assemble_name(asm_out_file, name);
+  fputc ('\n', asm_out_file);
+
+  switch_to_section (get_section (section, SECTION_WRITE, NULL));
+  assemble_align (POINTER_SIZE);
+  fprintf (asm_out_file, "\t.long %s\n", label);
+}
+
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+void
+m68k_init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */
+			      tree fntype)	/* tree ptr for function decl */
+{
+printf("%s fntype==NULL -> %s\n", __FUNCTION__, fntype ? "no":"yes");
+if(fntype) printf("%s DECL_STATIC_CHAIN (fntype) = %i\n", __FUNCTION__, DECL_STATIC_CHAIN (fntype));
+printf("%s m68k_fastcall_function (fntype) = %i\n", __FUNCTION__, m68k_fastcall_function (fntype));
+  cum->last_arg_reg = -1;
+  cum->regs_already_used = 0;
+  cum->fntype = fntype;
+	
+#if ! defined (PCC_STATIC_STRUCT_RETURN) && defined (M68K_STRUCT_VALUE_REGNUM)
+  /* If return value is a structure, and we pass the buffer address in a
+     register, we can't use this register for our own purposes.
+     FIXME: Something similar would be useful for static chain.  */
+  if (fntype && aggregate_value_p (TREE_TYPE (fntype), fntype))
+    cum->regs_already_used |= (1 << M68K_STRUCT_VALUE_REGNUM);
+#endif
+}
+
+
+static void
 m68k_compute_frame_layout (void)
 {
   int regno, saved;
@@ -1454,7 +1701,7 @@
 }
 
 /* On the m68k all args are always pushed.  */
-
+/*
 static rtx
 m68k_function_arg (cumulative_args_t cum ATTRIBUTE_UNUSED,
 		   machine_mode mode ATTRIBUTE_UNUSED,
@@ -1463,7 +1710,89 @@
 {
   return NULL_RTX;
 }
+*/
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
 
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.  */
+
+static tree m68k_previous_fndecl = NULL;
+rtx m68k_function_arg (cumulative_args_t cum_v, machine_mode mode,
+        		      const_tree type, bool named)
+{
+	CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+	printf("%s %p %p\n", __FUNCTION__, (void*)TREE_TYPE (current_function_decl), (void*)cum->fntype);
+
+	if(m68k_fastcall_function(cum->fntype))
+	{
+		int regbegin = -1, regend, len;
+
+		/* only pass float and _Complex float to register
+
+		*/
+		if ((!TARGET_HARD_FLOAT || M68K_FASTCALL_FP_PARM == 0)
+			&& FLOAT_MODE_P (mode) && GET_MODE_UNIT_SIZE (mode) <= 4)
+		{
+			regbegin = 0; /* Dx */
+			regend = regbegin + M68K_FASTCALL_DATA_PARM;
+			len = ((GET_MODE_UNIT_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD) * GET_MODE_NUNITS(mode);
+		}
+		else if ((TARGET_HARD_FLOAT && M68K_FASTCALL_FP_PARM !=0 )
+			&& FLOAT_MODE_P (mode) && GET_MODE_UNIT_SIZE (mode) <= TARGET_FP_REG_SIZE
+			&& (GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT || mode == SCmode))
+		{
+			regbegin = 16; /* FPx */
+			regend = regbegin + M68K_FASTCALL_FP_PARM;
+			len = GET_MODE_NUNITS (mode);
+		}
+		else if (INTEGRAL_MODE_P (mode) && type && POINTER_TYPE_P (type))
+		{
+			regbegin = 8; /* Ax */
+			regend = regbegin + M68K_FASTCALL_ADDR_PARM;
+			len = 1;
+		}
+		else if (INTEGRAL_MODE_P (mode))
+		{
+			len = ((GET_MODE_UNIT_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD) * GET_MODE_NUNITS(mode);
+			regbegin = 0; /* Dx */
+			regend = regbegin + M68K_FASTCALL_DATA_PARM;
+		}
+
+		if (regbegin != -1)
+		{
+			int reg;
+			for (reg = regbegin; reg < regend; reg++)
+			{
+				long mask = 1 << reg;
+				if (!(cum->regs_already_used & mask) && (reg + len  <= regend))
+				{
+					cum->last_arg_reg = reg;
+					cum->last_arg_len = len;
+					break;
+				}
+			}
+		}
+
+		if (!named)
+			cum->regs_already_used = -1;
+
+		if (cum->last_arg_reg != -1)
+		{
+			printf("%s %i\n", __FUNCTION__, cum->last_arg_reg);
+			return gen_rtx_REG (mode, cum->last_arg_reg);
+		}
+	}
+	return NULL_RTX;
+}
+
+
+/*
 static void
 m68k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,
 			   const_tree type, bool named ATTRIBUTE_UNUSED)
@@ -1474,7 +1803,86 @@
 	   ? (GET_MODE_SIZE (mode) + 3) & ~3
 	   : (int_size_in_bytes (type) + 3) & ~3);
 }
+*/
+void
+m68k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode ATTRIBUTE_UNUSED,
+				const_tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)
+{
+	CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+	if (cum->last_arg_reg != -1) {
+		int count;
+		for (count = 0; count < cum->last_arg_len; count++)
+			cum->regs_already_used |= (1 << (cum->last_arg_reg + count));
+		cum->last_arg_reg = -1;
+		if (TREE_TYPE (current_function_decl) == cum->fntype && cum->regs_already_used != -1) {
+			tree attr_regparms = lookup_attribute ("*regparms", TYPE_ATTRIBUTES (cum->fntype));
+			if (attr_regparms) {
+				TREE_VALUE (attr_regparms) = build_int_cst (long_integer_type_node, cum->regs_already_used);
+			} else {
+				TYPE_ATTRIBUTES (cum->fntype) = tree_cons (get_identifier ("*regparms"),
+					build_int_cst (long_integer_type_node, cum->regs_already_used),
+					TYPE_ATTRIBUTES (cum->fntype));
+			}
+		}
+	}
+}
 
+/* if fascall is used we must save all register-args before mcount is calling
+   and restore after mcount. The special attribute "*regparm" only exists for
+   fastcall functions. "fastcall" and profiling makes no realy sense.
+   fp regs are not saved we asume mcount don't deal with it */
+void m68k_profile_function(FILE *file, int funcdef_no ATTRIBUTE_UNUSED, unsigned long saved_regs) {
+	unsigned long regs_to_save = 0, nregs = 0;
+	char movem_regs[3*16+1+4*8+1], *p = movem_regs;
+	tree attr_regparms = lookup_attribute ("*regparms", TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl)));
+	if (attr_regparms) {
+		regs_to_save = int_cst_value (TREE_VALUE(attr_regparms));
+	}
+	regs_to_save &= ~saved_regs; // mask out already saved regs
+	for (int reg=0; reg <16; ++reg) {
+		if (regs_to_save & (1UL << reg)) {
+			nregs += 1;
+			*p++ = '/';
+			*p++ = reg < 8 ? 'd' : 'a';
+			*p++ = '0' + reg % 8;
+		}
+	}
+	*p++ = 0;
+	// push regs
+	if (nregs < MIN_MOVEM_REGS) {
+		for(int reg = 0; reg < 16; ++reg)
+			if(regs_to_save & (1UL<<reg)) ASM_OUTPUT_REG_PUSH(file, reg);
+	} else {
+		if (TARGET_COLDFIRE) asm_fprintf (file, (MOTOROLA
+				? "\tlea -%i(%Rsp),%Rsp\n"
+				: "\tlea %Rsp@(-%i),%Rsp\n"),
+				(int)nregs * 4);
+		asm_fprintf (file, (MOTOROLA
+				? "\tmovem.l %s,%s(%Rsp)\n"
+				: "\tmoveml %s,%Rsp@%s\n"),
+				movem_regs + 1, TARGET_COLDFIRE ? "":"-");
+	}
+
+	// call mcount
+	M68K_FUNCTION_PROFILER(file, funcdef_no);
+
+	// pop regs
+	if (nregs < MIN_MOVEM_REGS) {
+		for(int reg = 15; reg >= 0; --reg)
+			if(regs_to_save & (1UL<<reg)) ASM_OUTPUT_REG_POP(file, reg);
+	} else {
+		asm_fprintf (file, (MOTOROLA
+				? "\tmovem.l (%Rsp)%s,%s\n"
+				: "\tmoveml %Rsp@%s,%s\n"),
+				TARGET_COLDFIRE ? "":"+", movem_regs + 1);
+		if (TARGET_COLDFIRE) asm_fprintf (file, (MOTOROLA
+				? "\tlea %i(%Rsp), %Rsp\n"
+				: "\tlea %Rsp@(%i), %Rsp\n"),
+				(int)nregs * 4);
+	}
+}
+
+
 /* Convert X to a legitimate function call memory reference and return the
    result.  */
 
@@ -5159,6 +5567,12 @@
     SET_REGNO (pic_offset_table_rtx, PIC_REG);
 }
 
+static bool
+m68k_promote_prototypes (const_tree t ATTRIBUTE_UNUSED)
+{
+    return !TARGET_FASTCALL;
+}
+
 /* Worker function for TARGET_STRUCT_VALUE_RTX.  */
 
 static rtx
@@ -5165,6 +5579,8 @@
 m68k_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,
 		       int incoming ATTRIBUTE_UNUSED)
 {
+//	if(m68k_fastcall_function(fntype))
+//		return gen_rtx_REG (Pmode, M68K_FASTCALL_STRUCT_VALUE_REGNUM);
   return gen_rtx_REG (Pmode, M68K_STRUCT_VALUE_REGNUM);
 }
 
@@ -5391,6 +5807,64 @@
 }
 #endif
 
+/* Remember the last target of m68k_set_current_function.  */
+//static tree m68k_previous_fndecl = NULL;
+//static tree m68k_current_fndecl = NULL;
+
+/* Establish appropriate back-end context for processing the function
+   FNDECL.  The argument might be NULL to indicate processing at top
+   level, outside of any function scope.  */
+static void
+m68k_set_current_function (tree fndecl) {
+  /* Only change the context if the function changes.  This hook is called
+     several times in the course of compiling a function, and we don't want to
+     slow things down too much or call target_reinit when it isn't safe.  */
+	if (fndecl && fndecl != m68k_previous_fndecl) {
+		printf("%s switch function from ", __FUNCTION__);
+		if(m68k_previous_fndecl) {
+			tree name = DECL_NAME (m68k_previous_fndecl);
+			printf("%s to ", name ? IDENTIFIER_POINTER(name): "noname");
+		}else printf ("none to ");
+		tree name = DECL_NAME (fndecl);
+		printf("%s fastcall=%i", name ? IDENTIFIER_POINTER(name): "noname", m68k_fastcall_function(fndecl));
+		printf(" static chain=%i (%p)\n", DECL_STATIC_CHAIN (fndecl), (void*)TREE_TYPE(fndecl));
+		bool prev_is_fastcall = m68k_fastcall_function(m68k_previous_fndecl);
+		bool curr_is_fastcall = m68k_fastcall_function(fndecl);
+
+		if(prev_is_fastcall != curr_is_fastcall) {
+			bool switch_fastcall = false;
+			if (TARGET_FASTCALL == !curr_is_fastcall) {
+				switch_fastcall = true;
+				target_flags ^= MASK_FASTCALL;
+			}
+			m68k_conditional_register_usage();
+			m68k_order_regs_for_local_alloc();
+			if(curr_is_fastcall)
+				call_really_used_regs[M68K_FASTCALL_STATIC_CHAIN_REGNUM] =
+				call_used_regs[M68K_FASTCALL_STATIC_CHAIN_REGNUM] = 1;
+			if (switch_fastcall)
+				target_flags ^= MASK_FASTCALL;
+		}
+		m68k_previous_fndecl = fndecl;
+	}
+}
+
+void
+m68k_order_regs_for_local_alloc (void)
+{
+  int i;
+  int pos = 0;
+  for (i = 0; i < 16; i ++)
+    if (call_used_regs [i] && !fixed_regs[i])
+      reg_alloc_order[pos++] = i;
+  for (i = 0; i < 16; i ++)
+    if (!(call_used_regs [i] && !fixed_regs[i]))
+      reg_alloc_order[pos++] = i;
+  reg_alloc_order[pos++] = 24;
+  for (i = 16; i < 24; i++)
+    reg_alloc_order[pos++] = i;
+}
+
 /* CPU to schedule the program for.  */
 enum attr_cpu m68k_sched_cpu;
 
@@ -6504,8 +6978,16 @@
 /* We generate a two-instructions program at M_TRAMP :
 	movea.l &CHAIN_VALUE,%a0
 	jmp FNADDR
-   where %a0 can be modified by changing STATIC_CHAIN_REGNUM.  */
+   where %a0 can be modified by changing STATIC_CHAIN_REGNUM.
 
+	on fastcall STATIC_CHAIN_REGNUM is outside call_used_regs
+	we generate a four-instructions program at M_TRAMP
+	move.l %a0, -(sp)
+	movea.l &CHAIN_VALUE,%a0
+	jsr FNADDR
+ 	movea.l (sp)+, %a0
+*/
+
 static void
 m68k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
 {
@@ -6513,16 +6995,26 @@
   rtx mem;
 
   gcc_assert (ADDRESS_REGNO_P (STATIC_CHAIN_REGNUM));
-
-  mem = adjust_address (m_tramp, HImode, 0);
+  int adjust = 0;
+  bool is_fastcall = m68k_fastcall_function(fndecl);
+  if (is_fastcall) {
+  	mem = adjust_address (m_tramp, HImode, adjust);
+  	emit_move_insn (mem, GEN_INT(0x2F08 + (STATIC_CHAIN_REGNUM-8))); // move.l STATIC_CHAIN_REGNUM, -(sp)
+  	mem = adjust_address (m_tramp, SImode, adjust+=2);
+  }
+  mem = adjust_address (m_tramp, HImode, adjust);
   emit_move_insn (mem, GEN_INT(0x207C + ((STATIC_CHAIN_REGNUM-8) << 9)));
-  mem = adjust_address (m_tramp, SImode, 2);
+  mem = adjust_address (m_tramp, SImode, adjust+=2);
   emit_move_insn (mem, chain_value);
 
-  mem = adjust_address (m_tramp, HImode, 6);
-  emit_move_insn (mem, GEN_INT(0x4EF9));
-  mem = adjust_address (m_tramp, SImode, 8);
+  mem = adjust_address (m_tramp, HImode, adjust+=4);
+  emit_move_insn (mem, GEN_INT(is_fastcall ? 0x4EB9 : 0x4EF9)); // JSR (fastcal) or JMP)
+  mem = adjust_address (m_tramp, SImode, adjust+=2);
   emit_move_insn (mem, fnaddr);
+  if (is_fastcall) {
+  	mem = adjust_address (m_tramp, SImode, adjust+=4);
+  	emit_move_insn (mem, GEN_INT(0x205F + ((STATIC_CHAIN_REGNUM-8) << 9))); // movea.l (sp)+, STATIC_CHAIN_REGNUM
+  }
 
   FINALIZE_TRAMPOLINE (XEXP (m_tramp, 0));
 }
@@ -6555,6 +7047,37 @@
 m68k_conditional_register_usage (void)
 {
   int i;
+  int num_of_dregs = (TARGET_FASTCALL) ? M68K_FASTCALL_USED_DATA_REGS : M68K_STD_USED_REGS;
+  int num_of_aregs = (TARGET_FASTCALL) ? M68K_FASTCALL_USED_ADDR_REGS : M68K_STD_USED_REGS;
+  int num_of_fpregs = (TARGET_FASTCALL) ? M68K_FASTCALL_USED_FP_REGS : M68K_STD_USED_REGS;
+  for (i = 0; i < 8; i++)
+    {
+      call_used_regs[i] = (i < num_of_dregs) | fixed_regs[i];
+      call_used_regs[i + 8] = (i < num_of_aregs) | fixed_regs[i + 8];
+      call_used_regs[i + 16] = (i < num_of_fpregs) | fixed_regs[i + 16];
+    }
+  if (flag_pic)
+    fixed_regs[PIC_REG] = 1;
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    {
+       call_used_regs[i] |= fixed_regs[i];
+       call_really_used_regs[i] = call_used_regs[i];
+    }
+  if (!TARGET_HARD_FLOAT)
+    {
+      HARD_REG_SET x;
+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);
+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+        if (TEST_HARD_REG_BIT (x, i))
+          fixed_regs[i] = call_used_regs[i] = 1;
+    }
+}
+
+/*
+static void
+m68k_conditional_register_usage (void)
+{
+  int i;
   HARD_REG_SET x;
   if (!TARGET_HARD_FLOAT)
     {
@@ -6566,7 +7089,9 @@
   if (flag_pic)
     fixed_regs[PIC_REG] = call_used_regs[PIC_REG] = 1;
 }
+*/
 
+
 static void
 m68k_init_sync_libfuncs (void)
 {
Index: gcc/config/m68k/m68k.h
===================================================================
--- gcc/config/m68k/m68k.h	(Revision 2)
+++ gcc/config/m68k/m68k.h	(Arbeitskopie)
@@ -131,8 +131,21 @@
 	}								\
 									\
       if (TARGET_68881)							\
-	builtin_define ("__HAVE_68881__");				\
+	{								\
+	  builtin_define ("__HAVE_68881__");				\
+	  builtin_define ("__M68881__"); /* Non-standard */		\
+	}								\
 									\
+      if (TARGET_SHORT)                                                 \
+        {                                                               \
+      	  builtin_define ("__SHORT__"); /* Non-standard */		\
+        }                                                               \
+                                                                        \
+      if (TARGET_FASTCALL)                                              \
+        {                                                               \
+      	  builtin_define ("__FASTCALL__"); /* Non-standard */		\
+        }                                                               \
+                                                                        \
       if (TARGET_COLDFIRE)						\
 	{								\
 	  const char *tmp;						\
@@ -193,6 +206,11 @@
 									\
       builtin_assert ("cpu=m68k");					\
       builtin_assert ("machine=m68k");					\
+      builtin_define ("__shortcall=__attribute__((shortcall))");		\
+      builtin_define ("__longcall=__attribute__((longcall))");		\
+      builtin_define ("__fastcall=__attribute__((fastcall))");		\
+      builtin_define ("__cdecl=__attribute__((stkparm))");		\
+      builtin_define ("cdecl=__attribute__((stkparm))");		\
     }									\
   while (0)
 
@@ -408,6 +426,7 @@
 
 #define STATIC_CHAIN_REGNUM A0_REG
 #define M68K_STATIC_CHAIN_REG_NAME REGISTER_PREFIX "a0"
+#define M68K_FASTCALL_STATIC_CHAIN_REGNUM A2_REG
 
 /* Register in which address to store a structure value
    is passed to a function.  */
@@ -470,7 +489,7 @@
 
 #define PUSH_ROUNDING(BYTES) m68k_push_rounding (BYTES)
 
-#define FIRST_PARM_OFFSET(FNDECL) 8
+#define FIRST_PARM_OFFSET(FNDECL) (DECL_STATIC_CHAIN (FNDECL) && m68k_fastcall_function(FNDECL) ? 16 : 8)
 
 /* On the m68k the return value defaults to D0.  */
 #define FUNCTION_VALUE(VALTYPE, FUNC)  \
@@ -488,17 +507,72 @@
 #define NEEDS_UNTYPED_CALL 0
 
 /* On the m68k, all arguments are usually pushed on the stack.  */
-#define FUNCTION_ARG_REGNO_P(N) 0
-
-/* On the m68k, this is a single integer, which is a number of bytes
-   of arguments scanned so far.  */
-#define CUMULATIVE_ARGS int
+/* 1 if N is a possible register number for function argument passing.  */
+#define FUNCTION_ARG_REGNO_P(N)			\
+  ((((int)N) >= 0 && (N) < M68K_FASTCALL_DATA_PARM)		\
+   || ((N) >= 8 && (N) < 8 + M68K_FASTCALL_ADDR_PARM)	\
+   || (TARGET_HARD_FLOAT && (N) >= 16 && (N) < 16 + M68K_FASTCALL_FP_PARM))
 
-/* On the m68k, the offset starts at 0.  */
+
+   
+/* The number of data registers and address registers to use for
+   fast calls. */
+#define M68K_FASTCALL_DATA_PARM 3
+#define M68K_FASTCALL_ADDR_PARM 2
+/* The number of fp registers to use for fast calls.
+   if M68K_FASTCALL_FP_PARM == 0 floats passed as DATA_PARM
+   otherwise floats always passed to fp-regs
+   if TARGET_HARD_FLOAT == false then M68K_FASTCALL_FP_PARM is implicit 0
+   NOTE: is M68K_FASTCALL_FP_PARM!= 0 makes calls incompatible with soft-fp */
+#define M68K_FASTCALL_FP_PARM 0
+
+// Call clobbered regs.
+#define M68K_STD_USED_REGS 2
+#define M68K_FASTCALL_USED_DATA_REGS 3
+#define M68K_FASTCALL_USED_ADDR_REGS 2
+#define M68K_FASTCALL_USED_FP_REGS M68K_FASTCALL_USED_DATA_REGS
+
+/* On the m68k, this is a structure:
+   regs_already_used: bitmask of the already used registers.
+   last_arg_reg - register number of the most recently passed argument.
+     -1 if passed on stack.
+   last_arg_len - number of registers used by the most recently passed
+     argument.
+*/
+
+struct m68k_args
+{
+  long regs_already_used;
+  int last_arg_reg;
+  int last_arg_len;
+  tree fntype;
+};
+
+#define CUMULATIVE_ARGS struct m68k_args
+
+/* The default number of data, address and float registers to use when
+   user specified '-mregparm' switch, not '-mregparm=<value>' option.  */
+
+#define ADJUST_REG_ALLOC_ORDER m68k_order_regs_for_local_alloc ()
+
 #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \
- ((CUM) = 0)
+  (m68k_init_cumulative_args (&(CUM), (FNTYPE)))
 
+/*#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)	\
+  (m68k_function_arg_advance (&(CUM))) */
+
+/* On m68k all args are pushed, except if -mfastcall then d0-2, a0-1 and
+   fp0-2 are used for passing the first arguments.
+   Note: by default, the static-chain is passed in a0. Targets that want
+   to make full use of '-mfastcall' are advised to pass the static-chain
+   somewhere else.  */
+/*#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  (m68k_function_arg (&(CUM), (MODE), (TYPE), (NAMED))) */
+
 #define FUNCTION_PROFILER(FILE, LABELNO)  \
+    m68k_profile_function(FILE, LABELNO, ((chain && REG_P(chain)) ? 1UL << REGNO (chain) : 0) | ((sval && REG_P(sval)) ? 1UL << REGNO (sval) : 0));
+
+#define M68K_FUNCTION_PROFILER(FILE, LABELNO)  \
   asm_fprintf (FILE, "\tlea %LLP%d,%Ra0\n\tjsr mcount\n", (LABELNO))
 
 #define EXIT_IGNORE_STACK 1
@@ -523,7 +597,7 @@
    Since more instructions are required to move a template into
    place than to create it on the spot, don't use a template.  */
 
-#define TRAMPOLINE_SIZE 12
+#define TRAMPOLINE_SIZE (12 + 4) // in fastcall need extra inst to save & rest STATIC_CHAIN_REG
 #define TRAMPOLINE_ALIGNMENT 16
 
 /* Targets redefine this to invoke code to either flush the cache,
@@ -545,6 +619,8 @@
    (though the operand list is empty).  */
 #define TRANSFER_FROM_TRAMPOLINE				\
 void								\
+__transfer_from_trampoline ();					\
+void								\
 __transfer_from_trampoline ()					\
 {								\
   register char *a0 asm (M68K_STATIC_CHAIN_REG_NAME);		\
@@ -947,4 +1023,6 @@
 extern int m68k_sched_address_bypass_p (rtx_insn *, rtx_insn *);
 extern int m68k_sched_indexed_address_bypass_p (rtx_insn *, rtx_insn *);
 
+extern void m68k_compute_slb_export (tree fndecl);
+
 #define CPU_UNITS_QUERY 1
Index: gcc/config/m68k/m68k.md
===================================================================
--- gcc/config/m68k/m68k.md	(Revision 2)
+++ gcc/config/m68k/m68k.md	(Arbeitskopie)
@@ -133,6 +133,7 @@
   [(D0_REG		0)
    (A0_REG		8)
    (A1_REG		9)
+   (A2_REG		10)
    (PIC_REG		13)
    (A6_REG		14)
    (SP_REG		15)
@@ -7159,7 +7160,7 @@
     }
   else if (MOTOROLA)
     {
-      if (TARGET_COLDFIRE)
+      if (TARGET_COLDFIRE || !TARGET_68020)
 	/* Load the full 32-bit PC-relative offset of
 	   _GLOBAL_OFFSET_TABLE_ into the PIC register, then use it to
 	   calculate the absolute value.  The offset and "lea"
Index: gcc/config/m68k/m68k.opt
===================================================================
--- gcc/config/m68k/m68k.opt	(Revision 2)
+++ gcc/config/m68k/m68k.opt	(Arbeitskopie)
@@ -158,6 +158,10 @@
 Target RejectNegative InverseMask(SHORT)
 Consider type 'int' to be 32 bits wide.
 
+mnofastcall
+Target RejectNegative InverseMask(FASTCALL)
+Use standard calling conventions.
+
 mpcrel
 Target Report Mask(PCREL)
 Generate pc-relative code.
@@ -178,6 +182,10 @@
 Target Report Mask(SHORT)
 Consider type 'int' to be 16 bits wide.
 
+mfastcall
+Target Report Mask(FASTCALL)
+Use calling convention passing arguments in registers.
+
 msoft-float
 Target RejectNegative InverseMask(HARD_FLOAT)
 Generate code with library calls for floating point.
Index: gcc/config/m68k/math-68881.h
===================================================================
--- gcc/config/m68k/math-68881.h	(Revision 2)
+++ gcc/config/m68k/math-68881.h	(Arbeitskopie)
@@ -44,6 +44,16 @@
 
 #include <errno.h>
 
+/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  */
+#ifdef __cplusplus
+# define __MATH_68881_INLINE inline
+#elif defined __GNUC_STDC_INLINE__
+# define __MATH_68881_INLINE extern __inline __attribute__ ((__gnu_inline__))
+#else
+# define __MATH_68881_INLINE extern __inline
+#endif
+
 #undef HUGE_VAL
 #ifdef __sun__
 /* The Sun assembler fails to handle the hex constant in the usual defn.  */
@@ -64,7 +74,7 @@
 })
 #endif
 
-__inline extern double
+__MATH_68881_INLINE double
 sin (double x)
 {
   double value;
@@ -75,7 +85,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cos (double x)
 {
   double value;
@@ -86,7 +96,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tan (double x)
 {
   double value;
@@ -97,7 +107,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 asin (double x)
 {
   double value;
@@ -108,7 +118,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 acos (double x)
 {
   double value;
@@ -119,7 +129,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan (double x)
 {
   double value;
@@ -130,7 +140,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atan2 (double y, double x)
 {
   double pi, pi_over_2;
@@ -187,7 +197,7 @@
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sinh (double x)
 {
   double value;
@@ -198,7 +208,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 cosh (double x)
 {
   double value;
@@ -209,7 +219,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 tanh (double x)
 {
   double value;
@@ -220,7 +230,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 atanh (double x)
 {
   double value;
@@ -231,7 +241,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 exp (double x)
 {
   double value;
@@ -242,7 +252,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 expm1 (double x)
 {
   double value;
@@ -253,7 +263,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log (double x)
 {
   double value;
@@ -264,7 +274,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log1p (double x)
 {
   double value;
@@ -275,7 +285,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 log10 (double x)
 {
   double value;
@@ -286,7 +296,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 sqrt (double x)
 {
   double value;
@@ -297,13 +307,13 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 hypot (double x, double y)
 {
   return sqrt (x*x + y*y);
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 pow (double x, double y)
 {
   if (x > 0)
@@ -352,7 +362,7 @@
     }
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fabs (double x)
 {
   double value;
@@ -363,7 +373,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ceil (double x)
 {
   int rounding_mode, round_up;
@@ -385,7 +395,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 floor (double x)
 {
   int rounding_mode, round_down;
@@ -408,7 +418,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 rint (double x)
 {
   int rounding_mode, round_nearest;
@@ -430,7 +440,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 fmod (double x, double y)
 {
   double value;
@@ -442,7 +452,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 drem (double x, double y)
 {
   double value;
@@ -454,7 +464,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 scalb (double x, int n)
 {
   double value;
@@ -466,7 +476,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 logb (double x)
 {
   double exponent;
@@ -477,7 +487,7 @@
   return exponent;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 ldexp (double x, int n)
 {
   double value;
@@ -489,7 +499,7 @@
   return value;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 frexp (double x, int *exp)
 {
   double float_exponent;
@@ -514,7 +524,7 @@
   return mantissa;
 }
 
-__inline extern double
+__MATH_68881_INLINE double
 modf (double x, double *ip)
 {
   double temp;
Index: gcc/config/m68k/mint.h
===================================================================
--- gcc/config/m68k/mint.h	(nicht existent)
+++ gcc/config/m68k/mint.h	(Arbeitskopie)
@@ -0,0 +1,319 @@
+/* Definitions of target machine for GNU compiler.
+   Atari ST TOS/MiNT.
+   Copyright (C) 1994, 1995, 2007, 2008, 2009, 2010, 2011
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http:/www.gnu.org/licenses/>.  */
+
+/* Here are four prefixes that are used by asm_fprintf to
+   facilitate customization for alternate assembler syntaxes.
+   Machines with no likelihood of an alternate syntax need not
+   define these and need not use asm_fprintf.  */
+
+/* The prefix for register names.  Note that REGISTER_NAMES
+   is supposed to include this prefix. Also note that this is NOT an
+   fprintf format string, it is a literal string */
+
+#undef REGISTER_PREFIX
+#define REGISTER_PREFIX "%"
+
+/* The prefix for local (compiler generated) labels.
+   These labels will not appear in the symbol table.  */
+
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+
+/* The prefix to add to user-visible assembler symbols.  */
+
+#undef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX "_"
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "|"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "short unsigned int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE SHORT_TYPE_SIZE
+
+#undef TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define ("__MINT__");		\
+      builtin_define_std ("atarist");		\
+      builtin_assert ("machine=atari");		\
+      builtin_assert ("system=mint");		\
+    }						\
+  while (0)
+
+#undef TARGET_OBJFMT_CPP_BUILTINS
+#define TARGET_OBJFMT_CPP_BUILTINS() do { builtin_define ("__ELF__"); } while (0)
+/* The following defines are nonstandard
+   and are kept only for compatibility
+   with older versions of GCC for MiNT.  */
+
+#undef CPP_SPEC
+#define CPP_SPEC			\
+  "%{m68000:-D__M68000__} "		\
+  "%{mc68020:-D__M68020__} "		\
+  "%{m68020:-D__M68020__} "		\
+  "%{m68030:-D__M68020__} "		\
+  "%{m68040:-D__M68020__} "		\
+  "%{m68060:-D__M68020__} "		\
+  "%{m68020-40:-D__M68020__} "		\
+  "%{m68020-60:-D__M68020__} "		\
+  "%{!m680*:%{!mc680*:-D__M68000__}} " \
+  "%{mthreads:-D_REENTRANT} "
+
+#define STARTFILE_SPEC	"%{slb:%{pg|p|profile:%eprofiling of shared libraries is not supported;:crt0.slb.o%s};:%{pg|p|profile:gcrt0.o%s;:crt0.o%s}}"
+#define LIB_SPEC	"%{cmini:-lcmini;:-lc} %{mthreads:-lpthread} "
+
+/* Every structure or union's size must be a multiple of 2 bytes.  */
+#define STRUCTURE_SIZE_BOUNDARY 16
+
+/* The -g option generates stabs debug information.  */
+#define DBX_DEBUGGING_INFO 1
+
+/* This is the assembler directive to equate two values.  */
+#undef SET_ASM_OP
+#define SET_ASM_OP		"\t.set\t"
+
+/* This is how we tell the assembler that a symbol is weak.  */
+#undef ASM_WEAKEN_LABEL
+#define ASM_WEAKEN_LABEL(FILE,NAME) \
+  do { fputs ("\t.weak\t", FILE); assemble_name (FILE, NAME); \
+       fputc ('\n', FILE); } while (0)
+
+#undef ASM_PREFERRED_EH_DATA_FORMAT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)	DW_EH_PE_pcrel
+
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* The system headers are C++-aware.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* By default, the vtable entries are void pointers, the so the alignment
+   is the same as pointer alignment.  The value of this macro specifies
+   the alignment of the vtable entry in bits.  It should be defined only
+   when special alignment is necessary.
+
+   MiNT: The default value of 32 is too much and unsupported by a.out-mintprg.
+*/
+#define TARGET_VTABLE_ENTRY_ALIGN 16
+
+/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that
+   the rest of the DWARF 2 frame unwind support is also provided.
+   
+   MiNT: DWARF 2 frame unwind is not supported by a.out-mint.
+*/
+#define DWARF2_UNWIND_INFO 1
+
+/* All ELF targets can support DWARF-2.  */
+
+#define DWARF2_DEBUGGING_INFO 1
+
+/* The GNU tools operate better with dwarf2, and it is required by some
+   psABI's.  Since we don't have any native tools to be compatible with,
+   default to dwarf2.  */
+
+#ifndef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+#endif
+
+/* All SVR4 targets use the ELF object file format.  */
+#define OBJECT_FORMAT_ELF
+
+/* Switch into a generic section.  */
+#undef  TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section
+#undef  TARGET_ASM_SELECT_RTX_SECTION
+#define TARGET_ASM_SELECT_RTX_SECTION default_elf_select_rtx_section
+#undef	TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION default_elf_select_section
+
+#define JUMP_TABLES_IN_TEXT_SECTION 1
+#undef LINK_SPEC
+#define LINK_SPEC "%{slb:-T m68k_magic_slb.ld -mbest-fit} -q %{mfastload}%{mno-fastload} %{maltram}%{mno-altram} %{mfastram}%{mno-mfastram} %{maltalloc}%{mno-maltalloc} %{mfastalloc}%{mno-mfastalloc} %{mbest-fit}%{mno-mbest-fit} %{msharable-text}%{mno-msharable-text} %{mshared-text}%{mno-mshared-text} %{mbasrel}%{mno-mbasrel}" \
+                  "%{mprivate-memory:%{mglobal-memory|msuper-memory|mreadonly-memory|mreadable-memory:%e-m*-memory options are exclusive;:-mprivate-memory}}" \
+                  "%{mglobal-memory:%{msuper-memory|mreadonly-memory|mreadable-memory:%e-m*-memory options are exclusive;:-mglobal-memory}}" \
+                  "%{msuper-memory:%{mreadonly-memory|mreadable-memory:%e-m*-memory options are exclusive;:-msuper-memory}}" \
+                  "%{mreadonly-memory} %{mreadable-memory}"
+
+/* config/m68k.md has an explicit reference to the program counter,
+   prefix this by the register prefix.  */
+
+#define ASM_RETURN_CASE_JUMP				\
+  do {							\
+    if (TARGET_COLDFIRE)				\
+      {							\
+	if (ADDRESS_REG_P (operands[0]))		\
+	  return "jmp %%pc@(2,%0:l)";			\
+	else						\
+	  return "ext%.l %0\n\tjmp %%pc@(2,%0:l)";	\
+      }							\
+    else						\
+      return "jmp %%pc@(2,%0:w)";			\
+  } while (0)
+
+/* The ADDR_DIFF_VEC must exactly follow the previous instruction.  */
+
+#undef ADDR_VEC_ALIGN
+#define ADDR_VEC_ALIGN(ADDR_VEC) 0
+
+/* If defined, a C expression whose value is a string containing the
+   assembler operation to identify the following data as uninitialized global
+   data.  */
+
+#define BSS_SECTION_ASM_OP "\t.bss"
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   FILE the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.
+   Try to use asm_output_aligned_bss to implement this macro.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* Support a read-only data section.  */
+#define READONLY_DATA_SECTION_ASM_OP	"\t.section\t.rodata"
+
+
+/* Disable -fpic and -fPIC since bsr.l _label@PLTPC
+   is unsupported by the assembler.  */
+
+#undef  SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+do {									\
+  if (flag_pic && !TARGET_PCREL)					\
+      error ("-f%s is not supported on this target",			\
+	       (flag_pic > 1) ? "PIC" : "pic");				\
+} while (0)
+
+/* Workaround for GCC bug #35067 about multiple thunks.  */
+
+#undef MAKE_DECL_ONE_ONLY
+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+
+/* Avoid requiring -static with -fmudflap like in config/bfin/uclinux.h */
+#define MFWRAP_SPEC " %{fmudflap|fmudflapth: \
+ --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\
+ --wrap=mmap --wrap=munmap --wrap=alloca\
+ %{fmudflapth: --wrap=pthread_create\
+}} %{fmudflap|fmudflapth: --wrap=main}"
+
+
+/* Older implementations of mcount expect the address of a counter
+   variable to be loaded into some register. The name of this variable is
+   prefix LP followed by a number.
+   mintlib's mcount dont use or need that  */
+#undef NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS 1
+#undef M68K_FUNCTION_PROFILER
+#define M68K_FUNCTION_PROFILER(FILE, LABELNO)  \
+  asm_fprintf (FILE, "\tjsr mcount\n")
+
+/* This is the library routine that is used to transfer control from the
+   trampoline to the actual nested function.  It is defined for backward
+   compatibility, for linking with object code that used the old trampoline
+   definition.*/
+/* MiNT don't needs backward compatibility */
+#undef TRANSFER_FROM_TRAMPOLINE
+
+
+#undef FINALIZE_TRAMPOLINE
+#define FINALIZE_TRAMPOLINE(TRAMP)							\
+	emit_library_call (init_one_libfunc("__clear_cache"),	\
+			LCT_NORMAL, VOIDmode, TRAMP, Pmode,				\
+			plus_constant (Pmode, TRAMP, TRAMPOLINE_SIZE), Pmode);
+
+/* Clear the instruction cache from `beg' to `end'.  This makes an
+   Gemdos call SSystem(S_FLUSHCACHE, ... ).  */
+
+#define CLEAR_INSN_CACHE(BEG, END)									\
+{																	\
+	static long available = 0;										\
+	if (available < 0 /* ENOSYS*/) return;							\
+	register long ret __asm__("%d0");								\
+	register long _BEG __asm__("%a0") = (long) BEG;					\
+	register long _END __asm__("%a1") = (long) END;					\
+	__asm__ volatile												\
+  	(																\
+ 		"subl	%1, %2\n\t"											\
+ 		"movl	%2,sp@-\n\t"										\
+  		"movl	%1,sp@-\n\t"										\
+  		"movl	#(340<<16)+16,sp@-\n\t" /* SSystem(S_FLUSHCACHE, ... ) */	\
+  		"trap	#1\n\t"					/* Gemdos call */			\
+  		"lea	sp@(12),sp"											\
+  	: "=r" (ret), "+a"(_BEG), "+a"((_END))							\
+  	:  /* inputs  */	\
+  	:  "d1", "d2", "a2"    /* clobbered regs */			\
+  	);																\
+	available = ret;												\
+}
+
+/* ColdFire and fido strongly prefer a 32-bit aligned stack.  */
+/* BUG with -mshort see GCC Bugzilla BUG 88160
+   --> temporary set PREFERRED_STACK_BOUNDARY to 16 for coldfire with mshort */
+#undef PREFERRED_STACK_BOUNDARY
+#define PREFERRED_STACK_BOUNDARY \
+  (((TARGET_COLDFIRE && !TARGET_SHORT) || TARGET_FIDOA) ? 32 : 16)
+
+
+
+
+/* the defines above should be in mint-stdint.h */
+
+
+#define SIG_ATOMIC_TYPE (INT_TYPE_SIZE == 16 ? "long int" : "int")
+
+#define INT8_TYPE "signed char"
+#define INT16_TYPE (INT_TYPE_SIZE == 16 ? "int" : "short int")
+#define INT32_TYPE (INT_TYPE_SIZE == 16 ? "long int" : "int")
+#define INT64_TYPE "long long int"
+#define UINT8_TYPE "unsigned char"
+#define UINT16_TYPE (INT_TYPE_SIZE == 16 ? "unsigned int" : "short unsigned int")
+#define UINT32_TYPE (INT_TYPE_SIZE == 16 ? "long unsigned int" : "unsigned int")
+#define UINT64_TYPE "long long unsigned int"
+
+#define INT_LEAST8_TYPE INT8_TYPE
+#define INT_LEAST16_TYPE INT16_TYPE
+#define INT_LEAST32_TYPE INT32_TYPE
+#define INT_LEAST64_TYPE INT64_TYPE
+#define UINT_LEAST8_TYPE UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE INT_LEAST8_TYPE
+#define INT_FAST16_TYPE "int"
+#define INT_FAST32_TYPE INT_LEAST32_TYPE
+#define INT_FAST64_TYPE INT_LEAST64_TYPE
+#define UINT_FAST8_TYPE UINT_LEAST8_TYPE
+#define UINT_FAST16_TYPE "unsigned int"
+#define UINT_FAST32_TYPE UINT_LEAST32_TYPE
+#define UINT_FAST64_TYPE UINT_LEAST64_TYPE
+
+#define INTPTR_TYPE PTRDIFF_TYPE
+#ifndef UINTPTR_TYPE
+#define UINTPTR_TYPE SIZE_TYPE
+#endif
+
Index: gcc/config/m68k/mint.opt
===================================================================
--- gcc/config/m68k/mint.opt	(nicht existent)
+++ gcc/config/m68k/mint.opt	(Arbeitskopie)
@@ -0,0 +1,67 @@
+slb
+Target
+create a shared library
+
+cmini
+Target
+link with libcmini instead with libc
+
+mthreads
+Target RejectNegative
+defines _REENTRANT and link with libpthread
+
+mfastload
+Target
+same as -Wl,--fastload (default)                 Enable/Disable not cleaning the heap on startup
+
+maltram
+Target
+same as -Wl,--altram (default)                   Enable/Disable loading into alternate RAM
+
+mfastram Alias(maltram)
+Target
+same as -Wl,--fastram (same as -maltram)         Enable/Disable loading into alternate RAM
+
+maltalloc
+Target
+same as -Wl,--altalloc (default)                 Enable/Disable malloc from alternate RAM
+
+mfastalloc
+Target
+same as -Wl,--fastalloc (same as -maltalloc)     Enable/Disable malloc from alternate RAM
+
+mbest-fit
+Target
+same as -Wl,--best-fit                           Enable/Disable loading with optimal heap size
+
+msharable-text
+Target
+same as -Wl,--sharable-text                      Enable/Disable sharing the text segment
+
+mshared-text
+Target
+same as -Wl,--shared-text (like -msharable-text) Enable/Disable sharing the text segment
+
+mbasrel
+Target
+same as -Wl,--basrel (same as -msharable-text)   Enable/Disable sharing the text segment
+
+mprivate-memory
+Target RejectNegative
+same as -Wl,--private-memory (default)           Process memory is not accessible
+
+mglobal-memory
+Target RejectNegative
+same as -Wl,--global-memory                      Process memory is readable and writable
+
+msuper-memory
+Target RejectNegative
+same as -Wl,--super-memory                       Process memory is accessible in supervisor mode
+
+mreadonly-memory
+Target RejectNegative
+same as -Wl,--readonly-memory                    Process memory is readable but not writable
+
+mreadable-memory
+Target RejectNegative
+same as -Wl,--readable-memory                    Process memory is readable but not writable
Index: gcc/config/m68k/t-mint
===================================================================
--- gcc/config/m68k/t-mint	(nicht existent)
+++ gcc/config/m68k/t-mint	(Arbeitskopie)
@@ -0,0 +1,41 @@
+# 
+# Use multiple libraries
+# 
+
+MULTILIB_OPTIONS = m68020-60/mcpu=5475 mshort
+
+MULTILIB_DIRNAMES = m68020-60 m5475 mshort
+
+MULTILIB_MATCHES = \
+	m68020-60=m68881 \
+	m68020-60=m68020 \
+	m68020-60=m68020-40 \
+	m68020-60=mc68020 \
+	m68020-60=m68030 \
+	m68020-60=m68040 \
+	m68020-60=m68060 \
+	m68020-60=mcpu?68020 \
+	m68020-60=mcpu?68030 \
+	m68020-60=mcpu?68040 \
+	m68020-60=mcpu?68060 \
+	m68020-60=march?68020 \
+	m68020-60=march?68030 \
+	m68020-60=march?68040 \
+	m68020-60=march?68060 \
+	mcpu?5475=mcfv4e \
+	mcpu?5475=mcpu?5470 \
+	mcpu?5475=mcpu?5471 \
+	mcpu?5475=mcpu?5472 \
+	mcpu?5475=mcpu?5473 \
+	mcpu?5475=mcpu?5474 \
+	mcpu?5475=mcpu?547x \
+	mcpu?5475=mcpu?5480 \
+	mcpu?5475=mcpu?5481 \
+	mcpu?5475=mcpu?5482 \
+	mcpu?5475=mcpu?5483 \
+	mcpu?5475=mcpu?5484 \
+	mcpu?5475=mcpu?5485 \
+	mcpu?5475=mcpu?548x
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
Index: gcc/cppdefault.c
===================================================================
--- gcc/cppdefault.c	(Revision 2)
+++ gcc/cppdefault.c	(Arbeitskopie)
@@ -24,6 +24,10 @@
 #include "tm.h"
 #include "cppdefault.h"
 
+#if defined(__MINGW32__) && defined(TARGET_SYSTEM_ROOT)
+#define NATIVE_SYSTEM_HEADER_DIR "/usr/include"
+#endif
+
 #ifndef NATIVE_SYSTEM_HEADER_COMPONENT
 #define NATIVE_SYSTEM_HEADER_COMPONENT 0
 #endif
Index: gcc/final.c
===================================================================
--- gcc/final.c	(Revision 2)
+++ gcc/final.c	(Arbeitskopie)
@@ -4719,6 +4719,7 @@
     targetm.asm_out.destructor (XEXP (DECL_RTL (current_function_decl), 0),
 				decl_fini_priority_lookup
 				  (current_function_decl));
+  m68k_compute_slb_export(current_function_decl);
   return 0;
 }
 
Index: gcc/function.c
===================================================================
--- gcc/function.c	(Revision 2)
+++ gcc/function.c	(Arbeitskopie)
@@ -3690,7 +3690,24 @@
    copying them into registers and using those registers as the DECL_RTL.  */
 
 static void
-assign_parms (tree fndecl)
+orig_assign_parms (tree fndecl);
+static void
+assign_parms (tree fndecl) {
+	bool need_restore=false;
+//	tree orig_integer_type_node = integer_type_node;
+//	tree orig_unsigned_type_node = unsigned_type_node;
+	if (TREE_CODE (fndecl) == FUNCTION_DECL) {
+		if ((!TARGET_SHORT && lookup_attribute ("shortcall", TYPE_ATTRIBUTES (TREE_TYPE(fndecl))))
+			|| (TARGET_SHORT && lookup_attribute ("longcall", TYPE_ATTRIBUTES (TREE_TYPE(fndecl))))) {
+			need_restore = true;
+			target_flags ^= MASK_SHORT;
+		}
+	}
+	orig_assign_parms(fndecl);
+	if (need_restore) target_flags ^= MASK_SHORT;
+}
+static void
+orig_assign_parms (tree fndecl)
 {
   struct assign_parm_data_all all;
   tree parm;
Index: gcc/graphite.h
===================================================================
--- gcc/graphite.h	(Revision 2)
+++ gcc/graphite.h	(Arbeitskopie)
@@ -37,6 +37,8 @@
 #include <isl/schedule.h>
 #include <isl/ast_build.h>
 #include <isl/schedule_node.h>
+#include <isl/id.h>
+#include <isl/space.h>
 
 typedef struct poly_dr *poly_dr_p;
 
Index: libcpp/init.c
===================================================================
--- libcpp/init.c	(Revision 2)
+++ libcpp/init.c	(Arbeitskopie)
@@ -220,7 +220,7 @@
   CPP_OPTION (pfile, bytes_big_endian) = 1;  /* does not matter */
 
   /* Default to no charset conversion.  */
-  CPP_OPTION (pfile, narrow_charset) = _cpp_default_encoding ();
+  CPP_OPTION (pfile, narrow_charset) = "ATARIST"; /* _cpp_default_encoding (); */
   CPP_OPTION (pfile, wide_charset) = 0;
 
   /* Default the input character set to UTF-8.  */
Index: libgcc/config.host
===================================================================
--- libgcc/config.host	(Revision 2)
+++ libgcc/config.host	(Arbeitskopie)
@@ -861,6 +861,9 @@
 	fi
 	md_unwind_header=m68k/linux-unwind.h
 	;;
+m68k-*-mint*)
+	tmake_file="$tmake_file m68k/t-floatlib"
+	;;
 m68k-*-rtems*)
 	tmake_file="$tmake_file m68k/t-floatlib"
 	extra_parts="$extra_parts crti.o crtn.o"
Index: libgcc/config/m68k/fpgnulib.c
===================================================================
--- libgcc/config/m68k/fpgnulib.c	(Revision 2)
+++ libgcc/config/m68k/fpgnulib.c	(Arbeitskopie)
@@ -111,10 +111,10 @@
   union float_long fl;
 
   fl.f = a;
-  if (EXP(fl.l) == EXP(~0u) && (MANT(fl.l) & ~HIDDEN) != 0)
+  if (EXP(fl.l) == EXP(~0ul) && (MANT(fl.l) & ~HIDDEN) != 0)
     return 1;
   fl.f = b;
-  if (EXP(fl.l) == EXP(~0u) && (MANT(fl.l) & ~HIDDEN) != 0)
+  if (EXP(fl.l) == EXP(~0ul) && (MANT(fl.l) & ~HIDDEN) != 0)
     return 1;
   return 0;
 }
@@ -290,7 +290,7 @@
 
   exp = EXPD (dl1) - EXCESSD + EXCESS;
 
-  sticky = dl1.l.lower & ((1 << 22) - 1);
+  sticky = dl1.l.lower & ((1ul << 22) - 1);
   mant = MANTD (dl1);
   /* shift double mantissa 6 bits so we can round */
   sticky |= mant & ((1 << 6) - 1);
Index: libgcc/config/m68k/lb1sf68.S
===================================================================
--- libgcc/config/m68k/lb1sf68.S	(Revision 2)
+++ libgcc/config/m68k/lb1sf68.S	(Arbeitskopie)
@@ -666,7 +666,9 @@
 	.globl SYM (__negdf2)
 	.globl SYM (__cmpdf2)
 	.globl SYM (__cmpdf2_internal)
+#ifdef __ELF__
 	.hidden SYM (__cmpdf2_internal)
+#endif
 
 	.text
 	.even
@@ -2581,7 +2583,9 @@
 	.globl SYM (__negsf2)
 	.globl SYM (__cmpsf2)
 	.globl SYM (__cmpsf2_internal)
+#ifdef __ELF__
 	.hidden SYM (__cmpsf2_internal)
+#endif
 
 | These are common routines to return and signal exceptions.	
 
Index: libgcc/unwind-dw2-fde.c
===================================================================
--- libgcc/unwind-dw2-fde.c	(Revision 2)
+++ libgcc/unwind-dw2-fde.c	(Arbeitskopie)
@@ -23,6 +23,11 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
+#if defined(__mcoldfire__) && defined(__MSHORT__)
+// this is only a bad hack
+#pragma GCC optimize "O0"
+#endif
+
 #ifndef _Unwind_Find_FDE
 #include "tconfig.h"
 #include "tsystem.h"
Index: libgcc/unwind-dw2.c
===================================================================
--- libgcc/unwind-dw2.c	(Revision 2)
+++ libgcc/unwind-dw2.c	(Arbeitskopie)
@@ -22,6 +22,11 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
+#if defined(__mcoldfire__) && defined(__MSHORT__)
+// this is only a bad hack
+#pragma GCC optimize "O0"
+#endif
+
 #include "tconfig.h"
 #include "tsystem.h"
 #include "coretypes.h"
@@ -40,7 +45,8 @@
 #ifdef HAVE_SYS_SDT_H
 #include <sys/sdt.h>
 #endif
-
+//void my_memset(void *, long, size_t);
+//#define memset my_memset
 #ifndef __USING_SJLJ_EXCEPTIONS__
 
 #ifndef __LIBGCC_STACK_GROWS_DOWNWARD__
Index: libiberty/configure
===================================================================
--- libiberty/configure	(Revision 2)
+++ libiberty/configure	(Arbeitskopie)
@@ -5108,6 +5108,8 @@
     hppa*64*-*-hpux*)
 	# PIC is the default for 64-bit PA HP-UX.
 	;;
+    *-*-mint*)
+	;;
     i[34567]86-*-cygwin* | x86_64-*-cygwin*)
 	;;
     i[34567]86-*-mingw* | x86_64-*-mingw*)
Index: libssp/ssp.c
===================================================================
--- libssp/ssp.c	(Revision 2)
+++ libssp/ssp.c	(Arbeitskopie)
@@ -65,6 +65,9 @@
 #ifdef HAVE_SYSLOG_H
 # include <syslog.h>
 #endif
+#ifdef __MINT__
+#include <mint/osbind.h>
+#endif
 
 void *__stack_chk_guard = 0;
 
@@ -114,6 +117,9 @@
 {
 #ifdef __GNU_LIBRARY__
   extern char * __progname;
+#elif defined (__MINT__)
+  extern char * program_invocation_short_name;
+  #define __progname program_invocation_short_name
 #else
   static const char __progname[] = "";
 #endif
@@ -155,6 +161,9 @@
     syslog (LOG_CRIT, "%s", msg3);
 #endif /* HAVE_SYSLOG_H */
 
+#ifdef __MINT__
+    Pterm(127);
+#else
   /* Try very hard to exit.  Note that signals may be blocked preventing
      the first two options from working.  The use of volatile is here to
      prevent optimizers from "knowing" that __builtin_trap is called first,
@@ -176,6 +185,7 @@
           break;
         }
   }
+#endif
 }
 
 void
Index: libstdc++-v3/config/os/mint/ctype_base.h
===================================================================
--- libstdc++-v3/config/os/mint/ctype_base.h	(nicht existent)
+++ libstdc++-v3/config/os/mint/ctype_base.h	(Arbeitskopie)
@@ -0,0 +1,66 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_base.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// Information as gleaned from /usr/include/ctype.h
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned short 	mask;
+    static const mask upper    	= _ISupper;
+    static const mask lower 	= _ISlower;
+    static const mask alpha 	= _ISupper | _ISlower;
+    static const mask digit 	= _ISdigit;
+    static const mask xdigit 	= _ISxdigit;
+    static const mask space 	= _ISspace;
+    static const mask print 	= _ISprint;
+    static const mask graph 	= _ISgraph;
+    static const mask cntrl 	= _IScntrl;
+    static const mask punct 	= _ISpunct;
+    static const mask alnum 	= _ISupper | _ISlower | _ISdigit;
+#if __cplusplus >= 201103L
+    static const mask blank	= _ISblank;
+#endif
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/config/os/mint/ctype_configure_char.cc
===================================================================
--- libstdc++-v3/config/os/mint/ctype_configure_char.cc	(nicht existent)
+++ libstdc++-v3/config/os/mint/ctype_configure_char.cc	(Arbeitskopie)
@@ -0,0 +1,99 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2011-2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ctype_configure_char.cc */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+#include <locale>
+#include <cstdlib>
+#include <cstring>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+// Information as gleaned from /usr/include/ctype.h
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  { return 0; }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del, 
+		     size_t __refs) 
+  : facet(__refs), _M_del(__table != 0 && __del), 
+  _M_toupper(NULL), _M_tolower(NULL), 
+  _M_table(__table ? __table : classic_table()) 
+  { 
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs) 
+  : facet(__refs), _M_del(__table != 0 && __del), 
+  _M_toupper(NULL), _M_tolower(NULL), 
+  _M_table(__table ? __table : classic_table())
+  { 
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return ::toupper((int) __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::toupper((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return ::tolower((int) __c); }
+
+  const char* 
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::tolower((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/config/os/mint/ctype_inline.h
===================================================================
--- libstdc++-v3/config/os/mint/ctype_inline.h	(nicht existent)
+++ libstdc++-v3/config/os/mint/ctype_inline.h	(Arbeitskopie)
@@ -0,0 +1,76 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+  
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+  
+// Mint C types, taken from mintlib-0.57.3/include/ctype.h
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  { return _ctype[(unsigned char)((__c) + 1)] & __m; }
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    while (__low < __high)
+      *__vec++ = _ctype[(*__low++) + 1] ;
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && !this->is(__m, *__low))
+      ++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && this->is(__m, *__low) != 0)
+      ++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/config/os/mint/os_defines.h
===================================================================
--- libstdc++-v3/config/os/mint/os_defines.h	(nicht existent)
+++ libstdc++-v3/config/os/mint/os_defines.h	(Arbeitskopie)
@@ -0,0 +1,36 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000-2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#define _GLIBCXX_OS_DEFINES 1
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+#endif
Index: libstdc++-v3/config/os/mint/ctype_base.h
===================================================================
--- libstdc++-v3/config/os/mint/ctype_base.h	(nicht existent)
+++ libstdc++-v3/config/os/mint/ctype_base.h	(Arbeitskopie)
@@ -0,0 +1,66 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_base.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// Information as gleaned from /usr/include/ctype.h
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned short 	mask;
+    static const mask upper    	= _ISupper;
+    static const mask lower 	= _ISlower;
+    static const mask alpha 	= _ISupper | _ISlower;
+    static const mask digit 	= _ISdigit;
+    static const mask xdigit 	= _ISxdigit;
+    static const mask space 	= _ISspace;
+    static const mask print 	= _ISprint;
+    static const mask graph 	= _ISgraph;
+    static const mask cntrl 	= _IScntrl;
+    static const mask punct 	= _ISpunct;
+    static const mask alnum 	= _ISupper | _ISlower | _ISdigit;
+#if __cplusplus >= 201103L
+    static const mask blank	= _ISblank;
+#endif
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/config/os/mint/ctype_configure_char.cc
===================================================================
--- libstdc++-v3/config/os/mint/ctype_configure_char.cc	(nicht existent)
+++ libstdc++-v3/config/os/mint/ctype_configure_char.cc	(Arbeitskopie)
@@ -0,0 +1,99 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2011-2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ctype_configure_char.cc */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+#include <locale>
+#include <cstdlib>
+#include <cstring>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+// Information as gleaned from /usr/include/ctype.h
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  { return 0; }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del, 
+		     size_t __refs) 
+  : facet(__refs), _M_del(__table != 0 && __del), 
+  _M_toupper(NULL), _M_tolower(NULL), 
+  _M_table(__table ? __table : classic_table()) 
+  { 
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs) 
+  : facet(__refs), _M_del(__table != 0 && __del), 
+  _M_toupper(NULL), _M_tolower(NULL), 
+  _M_table(__table ? __table : classic_table())
+  { 
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return ::toupper((int) __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::toupper((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return ::tolower((int) __c); }
+
+  const char* 
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::tolower((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/config/os/mint/ctype_inline.h
===================================================================
--- libstdc++-v3/config/os/mint/ctype_inline.h	(nicht existent)
+++ libstdc++-v3/config/os/mint/ctype_inline.h	(Arbeitskopie)
@@ -0,0 +1,76 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+  
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+  
+// Mint C types, taken from mintlib-0.57.3/include/ctype.h
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  { return _ctype[(unsigned char)((__c) + 1)] & __m; }
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    while (__low < __high)
+      *__vec++ = _ctype[(*__low++) + 1] ;
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && !this->is(__m, *__low))
+      ++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    while (__low < __high && this->is(__m, *__low) != 0)
+      ++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/config/os/mint/os_defines.h
===================================================================
--- libstdc++-v3/config/os/mint/os_defines.h	(nicht existent)
+++ libstdc++-v3/config/os/mint/os_defines.h	(Arbeitskopie)
@@ -0,0 +1,36 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000-2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#define _GLIBCXX_OS_DEFINES 1
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+#endif
Index: libstdc++-v3/configure
===================================================================
--- libstdc++-v3/configure	(Revision 2)
+++ libstdc++-v3/configure	(Arbeitskopie)
@@ -53783,7 +53783,7 @@
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris*)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris* | *-mint*)
 
   # All these tests are for C++; save the language and the compiler flags.
   # The CXXFLAGS thing is suspicious, but based on similar bits previously
Index: libstdc++-v3/configure.host
===================================================================
--- libstdc++-v3/configure.host	(Revision 2)
+++ libstdc++-v3/configure.host	(Arbeitskopie)
@@ -286,6 +286,10 @@
     esac
     OPT_LDFLAGS="${OPT_LDFLAGS} \$(lt_host_flags)"
     ;;
+  mint*)
+    SECTION_FLAGS="${SECTION_FLAGS} -D_GNU_SOURCE"
+    os_include_dir="os/mint"
+    ;;
   netbsd*)
     os_include_dir="os/bsd/netbsd"
     ;;
Index: libstdc++-v3/crossconfig.m4
===================================================================
--- libstdc++-v3/crossconfig.m4	(Revision 2)
+++ libstdc++-v3/crossconfig.m4	(Arbeitskopie)
@@ -183,7 +183,7 @@
 	;;
     esac
     ;;
-  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris*)
+  *-linux* | *-uclinux* | *-gnu* | *-kfreebsd*-gnu | *-cygwin* | *-solaris* | *-mint*)
     GLIBCXX_CHECK_COMPILER_FEATURES
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
